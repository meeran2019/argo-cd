---------------------------------------------------------------------------------------------------------
GitOps Introduction:
---------------------------------------------------------------------------------------------------------

GitOps:
    It is consider as an extension of infrastructure as code that uses Git as the version control system.
    GitOps operator is running in server(ex: kubernetes cluster), it pulls manifest from git repository. 
    Gitops operator compares the desired vs actual code.

GitOps Principles:
    1. Declarative vs Imperative -> Recommends declarative.
    2. Make use of Git. 
    3. GitOps operator (Software agent) runs in server.
    4. Reconcillation -> Actual state vs Desired state.

DevOps vs GitOps:
    Gitops is generally used in openshift/kubernetes.
    Devops is generally used for any application.

    Devops (changes pushed to server) => git -> CI (publish image to container) -> CD (kubectl apply)
    GitOps (changes pulled by git operator) => git -> CI (publish image to container) -> CD (pulls latest manifest)

Push vs Pull based deployment:
    Push based:
        All credentials to maintain in CI.
        Require RW access to k8s cluster.
    Pull based:
        Git operator run within cluster.
        CI/CD is integrated in server and not exposed.

GitOps Features:
    GitOps operator support multi cluster deployment.
    It eliminate configuration drift (team manually update in cluster)
    It doesnot help with secret management.
    It doesnot work well with multiple updates simultaneously as this works based on pull approach.

GitOps Tools:
    Gitops controller - Argo CD
    JenkinsX
    Helm Operator

---------------------------------------------------------------------------------------------------------
Argo CD Basics:
---------------------------------------------------------------------------------------------------------

Argo CD Introduction:
    It is declarative, Gitops continuos delivery tool for kubernets resources defined in git repository.
    It follows gitops patterns.

Terminology:
    Application             :   Group of kubernetes resources as defined by manifest file.
    Application Source Type :   Tool used to build application (Ex: Helm, Kustomize etc)
    Project                 :   Group of applications.

    Target state            :   Desired state as maintain in git.
    Live state              :   current live state of application.

    Synch Status            :   Whether or not live state matches target state.
    Sync                    :   Process of making target state as same as desired state.
    Sync operation status   :   Synch operation succeeded or not. 

    Refresh                 :   It takes latest code and compare live state and can initiate auto sync.
    Health                  :   Health of application.

Features:
    Automated deploy of appln to multiple clusters.
    Audit trials for appln events and API calls.
    SSO Integration.
    Webhook integration.
    Rollback 
    webUI 
    Automated drift detection.
    Provide prometheus metrics and grafana.
    Support multiple source type like helm etc.
    Support pre sync, sync, post sync hooks to support complex deployment.
    Multi tenancy and RBAC support.
    Support CLI and access token.
    Health status analyses.
    Automated or manual sync.

Architecture:
    It installed within cluster.
    Pull based so checks any changes in desired state.
    It also exposes API so can trigger by using jenkins, git webhook.

Installation:
    Core
    Multi tenant:
        Non high availability - install.yaml & namespace-install.yaml
        high availability - ha/install.yaml & ha/namespace-install.yaml

    https://argo-cd.readthedocs.io/en/stable/getting_started/


Application:
    It consists of project, source, destination and synch details.
    This can be created in CLI, YAML & UI.

UI: 
    Application -> Select source, destination.

CLI: 
    argocd app create app-name     

Settings:
    Useful to manage project repositories and configuration.
    Repository details are stored as secret in kubernetes cluster.

Project:
    Can create multiple projects and assign to repository, application etc.
    Roles are added to projects.


---------------------------------------------------------------------------------------------------------
ArgoCD Intermediate:
---------------------------------------------------------------------------------------------------------
    
Reconcillation Loop:
    Compare actual vs desired.
    By default, compares every 3 mins.
    Based on configmap value ARGOCD_RECONCILIATION_TIMEOUT
    Used in argocd-repo-server 

Update in configmap in seconds:
    apiVersion: v1
    data:
    timeout.reconciliation: 60s
    kind: ConfigMap
    metadata:

Git Webhook:
    Github -> send events to argo server -> argo repo server (which pulls)
    Github -> Settings -> Web hooks -> Add webhook ->  argo-url/api/webhook
    e.g. https://argocd.example.com/api/webhook
    Content type - application/json 

Application Health Check:
    Healthy -   All resources are 100% healthy.
    Progressing -   Resource is unhealthy but still be healthy in given time.
    Degraded -  Resource states indicate failure or inability to reach an healthy state.
    Missing - Resource is not present in cluster.
    Suspended - Resource is suspended or paused.
    Unknown - Health status is not known.

    Depends upon resources, does health check using Lua.
    Supports custom health check.

Sync Strategy Types:
    It consists of manual and automatic sync.
    Auto pruning of resources - What happens when files are deleted or removed from git.
    Self heal of cluster - What argocd does when make kubectl edit changes directly to cluster. 
    

